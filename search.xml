<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法基础课</title>
    <url>/2022/01/12/%E6%89%8B%E5%86%99%E5%A0%86/</url>
    <content><![CDATA[<p>下标从1开始比较方便, 从1开始比较方便<br>0 的左儿子是0，右边是1</p>
<ul>
<li>堆是一个完全二叉树： 通过1维数组进行存储<ul>
<li>小根堆为例每个点都是小于等于儿子</li>
<li>i的左儿子是2i，右儿子是2i+1</li>
<li>down(x)节点下移, up(X)节点上移</li>
</ul>
</li>
</ul>
<ol>
<li><p>插入一个数</p>
<p> 在最后一个位置插入之后，执行up操作</p>
</li>
<li><p>求最小值</p>
</li>
<li><p>删除最小值</p>
<p> 将最后一个元素覆盖到堆的顶部，执行down操作</p>
</li>
<li><p>删除任意一个元素</p>
<p> 将第k个点进行覆盖， k如果变大了向下走, 变小向上走</p>
</li>
<li><p>修改任意一个元素</p>
<p> 修改和删除类似，down和up</p>
</li>
</ol>
<hr>
<p>hash表和stl的介绍</p>
<p>存储结构</p>
<ul>
<li>开放寻址法</li>
<li>拉链法</li>
</ul>
<p>字符串hash方式</p>
<ul>
<li><p>字符串前缀hash法</p>
<p>  不能映射成数字0，否则可能会导致多次的映射为0。<br>  A映射为0，AA也成了0.<br>  预处理前缀的hash</p>
</li>
</ul>
<p>hash的mod的数一般取一个质数</p>
<hr>
<p>stl</p>
<ul>
<li>vector 对应slice 也就是变长数组</li>
<li>string string类型, 处理的包是strings</li>
<li>queue container下的list</li>
<li>priority_queue</li>
<li>stack container的heap</li>
<li>deque</li>
<li>set, map, multiset, multimap</li>
<li>bitset</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/01/08/hello_world/</url>
    <content><![CDATA[<h2 id="开始尝试静态博客"><a href="#开始尝试静态博客" class="headerlink" title="开始尝试静态博客"></a>开始尝试静态博客</h2>]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>打卡</title>
    <url>/2022/01/14/%E6%89%93%E5%8D%A1/%E6%89%93%E5%8D%A1/</url>
    <content><![CDATA[<h2 id="2022-01-14"><a href="#2022-01-14" class="headerlink" title="2022-01-14"></a>2022-01-14</h2><ol>
<li><p>acwing 算法基础课</p>
<ul>
<li><p>DFS: 栈, 空间和路径长度相关</p>
<ul>
<li>数字的全排列，只有单纯的回溯, 没有剪枝， 现场的恢复</li>
<li>n皇后问题：将相同对角线映射到一个下标, 对应题解的第一种</li>
</ul>
</li>
<li><p>BFS: queue, 空间是指数级别的， 可以搜索最近的点</p>
<ul>
<li>走迷宫</li>
<li>八数码： <ol>
<li>状态本身是一个二维数组, 表示比较复杂, </li>
<li>dist的表示相对来说也比较复杂,  距离数组的下标表示也比较复杂</li>
<li>状态的转移也需要进行考虑</li>
<li>注意下bfs的最短路径的数学证明</li>
</ol>
</li>
</ul>
</li>
<li><p>树和图的存储</p>
<ul>
<li>树是无环连通图</li>
<li>有向图存储<ul>
<li>邻接矩阵</li>
<li>邻接表：稀疏的图</li>
</ul>
</li>
</ul>
</li>
<li><p>树与图的深度优先遍历</p>
<ul>
<li>树的重心</li>
</ul>
</li>
<li><p>树和图的宽度优先遍历</p>
<ul>
<li>树的层次</li>
<li>求解图的拓扑排序</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="2022-01-15"><a href="#2022-01-15" class="headerlink" title="2022-01-15"></a>2022-01-15</h2><ol>
<li><p>acwing 算法基础课</p>
<ul>
<li><p>最短路算法</p>
<ul>
<li><p>单源最短路</p>
<ul>
<li><p>所有边的权都是正数</p>
<ol>
<li><p>朴素的Dijkstra算法 O(n * n)<br> 稠密图用朴素的比较合适<br> go 使用0x3f3f3f3f 设置无穷大</p>
</li>
<li><p>堆优化的Dijkstra算法 O(m * log n)<br> m 是边的数量<br> 存储方式变成临接表</p>
</li>
</ol>
</li>
<li><p>存在负权边</p>
<ol>
<li>Bellman-Ford (O nm)<br> n 次迭代, 每次循环所有边，a, b, w<br> 边的存储更加随意，只要能遍历到所有边即可<ul>
<li>有边数限制的最短路径</li>
<li>可以判断负环</li>
</ul>
</li>
<li>SPFA (O m), 最坏是O nm<ul>
<li>spfa要求不能包含负环</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>多源汇最短</p>
<ul>
<li>Floyd O (n**3)<br>  原理是基于动态规划<br>  d[k, i, j] i到j只经过1..k的最短距离<br>  邻接矩阵存储图</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>打卡</tag>
      </tags>
  </entry>
</search>
